<!DOCTYPE HTML>
<html lang="en"><!-- InstanceBegin template="/Templates/StandardContent.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<!-- InstanceBeginEditable name="doctitle" -->
<title>EmberJS</title>
<!-- InstanceEndEditable -->
<link href="../css/oneColFixCtr.css" rel="stylesheet" type="text/css">
<link href="../js/prettify/prettify.css" rel="stylesheet" type="text/css">
<!-- InstanceBeginEditable name="head" -->
<style type="text/css"></style>
<!-- InstanceEndEditable -->
</head>

<body>
<a href="../index.html" style="float:left"><img src="../img/home-button.svg" border="0"></a><!-- InstanceBeginEditable name="content" -->
<div class="title">EmberJS</div>
<h1>Learning Resources</h1>
<h2>Official Docs</h2>
<p><a href="http://guides.emberjs.com/" rel="external">EmberJS Guides</a></p>
<p><a href="http://emberjs.com/api" rel="external">EmberJS API</a></p>
<p><a href="http://www.ember-cli.com/#overview" rel="external">Ember CLI</a></p>
<h2>Lists</h2>
<p><a href="http://www.programwitherik.com/top-5-best-resources-for-ember-js/" rel="external">Top 5 Best Resources for EmberJS</a></p>
<p><a href="http://emberwatch.com/tutorials.html" rel="external">EmberWatch Tutorials</a></p>
<h2>Tutorials</h2>
<p><a href="http://www.thetechcofounder.com/getting-started-with-ember-js-using-ember-cli/" rel="external">getting-started-with-ember-js-using-ember-cli</a></p>
<p><a href="http://www.sitepoint.com/getting-started-with-ember-and-ember-cli/" target="external">http://www.sitepoint.com/getting-started-with-ember-and-ember-cli/</a></p>
<h2>Books in my iBooks Library</h2>
<p class="callout pushRight" style="width:40%;">The PacktPub books have code files than can be downloaded from the website.</p>
<p><em>Ember.js Web Development with Ember CLI</em> from PacktPub</p>
<p><a href="https://www.packtpub.com/web-development/mastering-emberjs" target="external"><em>Mastering Ember.js</em></a> from PacktPub.</p>
<p><em>Ember CLI 101</em> from leanpub.com.</p>
<p><em>Ember.js Guides</em> from leanpub.com.</p>
<p><em>Ember.js Guides Plus</em> from leanpub.com.</p>
<h1>Core Concepts</h1>
<p>These are features of Ember’s objects. See the <em>Ember.js Web Development with Ember CLI</em> book for more information.</p>
<h2>Mixins</h2>
<p>Reusable code that can be shared amongst your other modules (classes).</p>
<h2>Computed Properties</h2>
<p>A Method that returns a value.</p>
<h2>Getters and Setters</h2>
<p>Use to access properties of an Ember class.</p>
<h2>Observers</h2>
<p>Code that is triggered by an event (when a property’s value changes).</p>
<h2>Binding</h2>
<p>When the value of an object’s property actually comes from a <strong>different</strong> object.</p>
<h1>Routing</h1>
<p>A <em>route</em> is a url path and what should be done when that URI is requested. The route will specify two things:</p>
<ul>
	<li>The template to use.</li>
	<li>The data source.</li>
</ul>
<p>A <em>resource</em> is a group of routes. i.e. <code>user/, user/1, user/1/edit, user/1/delete</code>, etc.</p>
<p><code>/app/router.js</code> holds your Router Map, which is used to determine which Route to use.</p>
<p>Because one of Route’s jobs is to get your data, that is where you will place additional logic (say filtering the data source). Put it in <code>app/routes/<em><strong>path</strong></em>.js</code></p>
<h1>Ember Magical Bits</h1>
<h2>ES6 Modules (import/export)</h2>
<p>First, a bit of history. Asynchronous module definition (<strong>AMD</strong>) is a standard by which Javascript code is encapsulated and can have dependencies. This code can then be asynchronously loaded at run time. This was developed because Javascript doesn’t have a clean way to write classes nor manage dependencies. <strong><a href="http://requirejs.org/" rel="external">RequireJS</a></strong> is one implementation (and loader) of AMD modules.</p>
<p>The next version of Javascript (ECMAScript 6) attempts to resolve this through a new Module specification. By default anything you declare in a file in a ES6 project is not available outside that file. You have to use the <code>export</code> keyword to explicitly make it available. This bears repeating: If you attempt to create a global variable using:</p>
<p class="code">var foo = 'bar';</p>
<p>it will be available to the code inside the same <code>*.js</code> file, but not anywhere else.</p>
<p>This is new technology, and it is not available in browsers yet. However we can use it today with the use of a transpiler that converts ES6 syntax into plain Javascript.</p>
<h2>jQuery</h2>
<p>Ember uses jQuery. If you need to call jQuery then use this syntax to access Ember’s jQuery instance:</p>
<p><code>Ember.$('<em>your selector</em>').<em>method()</em>;</code></p>
<h2>The URL</h2>
<p>Ember will use HTML5 Pushstate for browsers that support it. This let’s you stay on the same page, but change the URL when accessing a different route. Users will be able to bookmark a deep link and get back to the same spot. They only problem here is those routes do not physically exist on your server so you’ll need to use rewrite rules, a fallback resource, or similar function of the web server.</p>
<p>If the browser doesn’t support Pushstate, then hashes are used on the URL (I think).</p>
<details>
	<summary>Rewrite Rules for Apache and Nginx</summary>
	<div>
		<h1><a href="http://readystate4.com/2012/05/17/nginx-and-apache-rewrite-to-support-html5-pushstate/" rel="bookmark" title="Permanent Link to Nginx and Apache rewrites to support HTML5 Pushstate in pure Backbone.js (or other JS MV*) Application.">Nginx and Apache rewrites to support HTML5 Pushstate in pure Backbone.js (or other JS MV*) Application.</a></h1>
		<h2>Posted on May 17th, 2012 in <a href="http://readystate4.com/category/apache/" title="View all posts in Apache" rel="category tag">Apache</a>, <a href="http://readystate4.com/category/backbone/" title="View all posts in backbone" rel="category tag">backbone</a>, <a href="http://readystate4.com/category/nginx/" title="View all posts in nginx" rel="category tag">nginx</a> | <a href="http://readystate4.com/2012/05/17/nginx-and-apache-rewrite-to-support-html5-pushstate/#comments" title="Comment on Nginx and Apache rewrites to support HTML5 Pushstate in pure Backbone.js (or other JS MV*) Application.">4 Comments »</a></h2>
	</div>
	<div>
		<p>HTML5 pushstate is awesome. It enables you to change the URL of your site dynamically without refreshing the page (goodbye hashes!). Libraries like <a href="http://backbonejs.org/">Backbone</a> have great support for this. Unfortunately if a user bookmarks or refresh a page on an app that&rsquo;s using HTML5 pushstate, it makes a request to the server for that deep linked content. Here are the rewrites for Nginx and Apache to internally redirect that call to the same html file. Browser thinks its a unique page but it&rsquo;s the same.</p>
		<h2>Apache</h2>
		<p>In your vhost :</p>
		<div>
			<div>
				<pre class="prettyprint linenums">&lt;IfModule mod_rewrite.c&gt;
	RewriteEngine On     
	RewriteBase /     
	RewriteRule ^index\.html$ - [L]     
	RewriteCond %{REQUEST_FILENAME} !-f     
	RewriteCond %{REQUEST_FILENAME} !-d     
	RewriteRule . /index.html [L]  
&lt;/IfModule&gt;</pre>
				<div style="padding-left:2em; border-left:solid medium orange;">
					<p><em>Note: A <a href="http://discuss.emberjs.com/t/apache-rewrite-rule-for-html5-browser-history-url-bookmarkability/1013" rel="external">different blog post</a> suggested this instead:</em></p>
					<p>I found a bunch of examples on the web of Apache rewrite rules that people are using for AJAX-based HTML5-history-using sites. All of them didn't work for me. I don't know why. But I thought it was Ember's fault. It wasn't. So I spun my wheels for a while blaming the router. It wasn't. It's just that there are some strange examples of rewrite rules on the web for AJAX-based HTML5-history-using sites. </p>
					<p>Below is what worked for me. I wanted to send every request for URLs to index.html, except for certain subdirectories (js, css, img, svc). If you do this in the root of your Apache config, you might need to specify a forward slash.</p>
					<pre class="prettyprint linenums">Options +FollowSymLinks 
RewriteEngine On 
RewriteBase / 
RewriteRule ^(js|css|img|svc)($|/) - [L] 
RewriteRule ^(.*)$ index.html [L]</pre>
				</div>
			</div>
		</div>
		<h2>Nginx</h2>
		<div>
			<div>
				<pre class="prettyprint linenums">rewrite ^(.+)$ /index.html last;</pre>
			</div>
		</div>
		<p>Note that once you have this in place your server no longer reports 400 errors as all requests pull up the index page. To work around this you can create a 404 in a Backbone route:</p>
		<div>
			<div>
				<pre class="prettyprint linenums">
routes: {     
	// Other routes     
	"*path"  : "notFound"   
},     
notFound: function(path) {     
	// Load 404 template, probably of a cute animal.   
}</pre>
			</div>
		</div>
	</div>
	<ul>
		<h2>4 Responses</h2>
		<li id="comment-2835"><a href="http://deserialized.com/" rel="external nofollow">Bryan Migliorisi</a>
			<div>
				<p>If you are using any modern MVC framework, it should be trivial to simply map all requests to the correct controller\action. I&rsquo;m doing this on a Rails project right now and I like it because it places the logic in the app instead of in the server and leaves less to worry about when deploying.</p>
			</div>
		</li>
		<li id="comment-2837">Mauvis
			<div>
				<p>Great point, Bryan. I guess I didn&rsquo;t add real context to this post. These kind of Nginx-level rewrites are really for backend-independent JavaScript application frameworks as most the apps I&rsquo;ve been writing lately have been straight Backbone.js which harness backend as API calls on the same or different server. The Apache version of the rewrites are for local dev environments as most developers are most familiar with that and already have it installed.</p>
				<p>Doing it this way enables me to decouple my backend from my front and allows me to put 95% of the entire application compressed and gzipped on the CDN sittin&rsquo; cool as a cucumber. The only servers I need to worry about scaling are the API servers, and I don&rsquo;t require the overhead of loading an entire backend application stack just to load a static html file.</p>
				<p>To target those few pages that require SEO (or Facebook sharing), I also use Nginx to serve seo friendly version when those deep links get hit directly (outside of HTML5 pushsate). I use Node Express which I&rsquo;m working on getting to understand my Backbone routes and templates directly without much extra coding.</p>
			</div>
		</li>
		<li id="comment-3172">Schmulik Raskin
			<div>
				<p>How are Ajax requests for dynamic resources handled, won&rsquo;t they also be redirected to &lsquo;index.html&rsquo;? Is there a way to ignore requests that are made from Ajax?</p>
			</div>
		</li>
		<li id="comment-3173">Mauvis
			<div>
				<p>Schmulik, I usually put API calls into its own domain served by the same or different web server, for example api.domain.com. I use CORS to support this but also have a work around domain.com/api/ for browsers that don&rsquo;t support CORS.</p>
			</div>
		</li>
	</ul>
</details>
<h2>Passing Data to Templates</h2>
<p>Ember component templates have a corresponding component module (Javascript file). So, if you need to pass a variable to the template, set it in the module first like this:</p>
<pre>import Ember from 'ember';

export default Ember.Component.extend({
	actions: {
		editTodo: function() {
			<strong>this.set('isEditing', true);</strong>
		},
		acceptChanges: function() {
			<strong>this.set('isEditing', false);</strong>
			this.sendAction('acceptChanges', this.get('todo'));
		},
		deleteTodo: function(todo) {
			this.sendAction('deleteTodo', todo);
		}
	}
});</pre>
<p>Then to use it in your template, reference the variable directly. e.g.</p>
<pre>&lt;li class=&quot;{{if todo.isCompleted 'completed'}}&quot;&gt;
	{{#if <strong>isEditing</strong>}}
		{{input type=&quot;text&quot; class=&quot;edit&quot; value=todo.title focus-out=&quot;acceptChanges&quot; insert-newline=&quot;acceptChanges&quot;}}
	{{else}}
		{{input type=&quot;checkbox&quot; checked=todo.isCompleted class=&quot;toggle&quot;}}
		&lt;label {{action &quot;editTodo&quot; on=&quot;doubleClick&quot;}}&gt;{{todo.title}}&lt;/label&gt;&lt;button {{action &quot;deleteTodo&quot; todo}} class=&quot;destroy&quot;&gt;&lt;/button&gt;
	{{/if}}
&lt;/li&gt;</pre>
<h1>Database Connectivity</h1>
<p>Normally your data is stored in a database, but it is possible to use a local data store. Ember calls this Fixture Data.</p>
<p>First create an adapter (see above).</p>
<div class="callout">
	<h2>You don't need Ember data</h2>
	<p>Here&rsquo;s something you might not know about Ember.js: It doesn&rsquo;t come default with a data library. It may sound a little strange that a <strong>model</strong>-view-controller framework doesn&rsquo;t come prepackaged with what a Rails developer would think of as <em>model</em>. In fact, a lot of the early complaints leveled at Ember (in the days when Ember Data was undergoing significant, break-your-application changes, like, <em>all the time</em>) was that if Data wasn&rsquo;t ready, what was the point of using Ember at all? </p>
	<pre>App.UserRoute = Ember.Route.extend({
model: function(params) {
    return this.store.find(user, params.user_id);
  }
});</pre>
	<p>That code is using Ember Data. But it doesn&rsquo;t have to be. See, the misunderstanding is that the <strong>model</strong> hook needs to return a proper Ember Model object. The truth is, it could return a plain JSON object and Ember would be just as happy. I could just do this…</p>
	<pre>App.UserRoute = Ember.Route.extend({
  model: function(params) {
    return {
      first_name: "Eric",
      last_name : "Sipple"
    };
  }    
});</pre>
	<p>…and our Controller gets a Model just the same. I use Ember Data because it provides a way to persist that data, and gives access to a really nice REST adapter, but there are a lot of people who are more than happy to deal with the REST parts on their own, and build a data object model that suits them better than what Ember Data does.</p>
	<p>Ember needs data, sure, but it doesn&rsquo;t need Ember Data.</p>
</div>
<p>&nbsp;</p>
<h1>Components</h1>
<p class="callout">Still trying to figure this out, but I think Components have replaced both Controllers and Views.</p>
<h1>Controllers</h1>
<p>I've not talked about controllers becasue they are being depreceated from Ember so why would you want to learn about them? In short controllers were used to decorate a template, show the temporary state of elements (component) on the page. Temporary state is the state of a element on the page that you don't want to be saved permenantly in your model, for example if we are editing a todo, we'd show an &lt;input&gt;box rather than a &lt;label&gt;. We most probably wouldn't want to save the editing state on our model so that it's premanantly available, therefore it's temporary and that decoration is handled by a controller. In the future of Ember, templates should be a collections of components (elements), and <strong>components</strong> will look after their own decoration/temporary state so a controller becomes redundant in most cases. Please forget all about controllers.</p>
<h1>Views</h1>
<p style="font-size:larger; font-weight:bold; text-align:center; padding-left:15%; padding-right:15%;">Views have been replaced with Components in most cases now. Keep that in mind when reading on...</p>
<div class="callout">
	<h2>Where does it go: view or controller?</h2>
	<p>Okay, so if Ember has Views, but doesn&rsquo;t use them to display anything, what exactly do they do? My misunderstanding of Ember Views stuck around longer than almost anything else in the framework, and I&rsquo;m still untangling things I did wrong because of it. Views are very easy to use for things they aren&rsquo;t meant for. Specifically, it&rsquo;s easy to start putting things in the View that really belong in the Controller, and vice versa.</p>
	<p>Luckily, the &ldquo;What are Views?&rdquo; question is pretty easy to answer. There are two things you might use them for:</p>
	<ol>
		<li>Creating reusable components; and</li>
		<li>Setting up logic to handle events.</li>
	</ol>
	<p>If your users had profile pictures, and you wanted to display those pictures on lots of different pages (y&rsquo;know, like not just on the user profile page), you might want to set that up as a View. Especially if you wanted that profile picture component to have some event logic behind it. Say you wanted people to be able to click the picture to pop up a larger version of the image. Your View could wait for a click event to hit the picture, then execute whatever logic you want as a result.</p>
	<p>Hold up, though. This is where I got turned around and put code in all the wrong places. A View is perfect for catching the browser event, but most of what you want to do as a result would go in the Controller.</p>
	<p>Basically, your View catches the click, then <strong>sends</strong> the event up to the Controller.</p>
	<pre class="prettyprint linenums">App.ProfilePhotoView = Ember.View.extend({
  click: function(evt) {
    this.get('controller').send('expandProfilePhoto');
  }
});

App.UserController = Ember.ObjectController.extend({
  actions: {
    expandProfilePhoto: function() {
      // Get the expanded picture and display it
      // We'll talk more about what to do here later
    }
  }
});</pre>
	<p>See that actions property in the UserController? Any methods you define in there can be called by the View with send.</p>
	<p>Ember won&rsquo;t stop you from putting a lot of logic into that click event that really belongs elsewhere, but you&rsquo;ll save yourself a lot of headaches if you let the Controller handle it.</p>
	<h2>Updating Fields</h2>
	<p>Do not directly update fields on the page; instead you should bind that field to the controller (or model?) and then update that instead.</p>
</div>
<h1>Content Security Policy (CSP)</h1>
<p>The relatively new CSP functionality does not want you to put inline styles on the DOM because it can be a security hole. If you can not change the source code to use, say, classes instead, then add a <em>contentSecurityPolicy</em> property to the <code>/config/environment.js</code> file.</p>
<pre class="prettyprint linenums">module.exports = function(environment) {
	var ENV = {
	modulePrefix: 'logic-model',
	environment: environment,
	baseURL: '/',
	locationType: 'auto',
	EmberENV: {
		FEATURES: {
		// Here you can enable experimental features on an ember canary build
		// e.g. 'with-controller': true
		}
	},
	APP: {
		// Here you can pass flags/options to your application instance
		// when it is created
	}, 
	<strong>contentSecurityPolicy: {
		'style-src': &quot;'self' 'unsafe-inline'&quot;
	}</strong>
};</pre>
<!-- InstanceEndEditable -->
<footer>
		<hr>
		<p style="font-size:1rem !important; text-align:left;margin-bottom:1em; float:left;"><a href="https://craig-creeger.github.io/">Table of Contents</a>
		</p>
		<p style="text-align:right; font-size:smaller;">Last updated on 
			<!-- #BeginDate format:Am1 -->October 28, 2015<!-- #EndDate --></p>
		<p class="tagLine" style="clear:left;">Making Every Pixel Count</p>
		<p><span id="copyrightDate">2015</span> &mdash; All rights reserved. <a href="http://pixelpro.biz/" title="Pixel Pro Web Design">Pixel Pro, Inc.</a></p>
</footer>
<script type="text/javascript" src="../js/jquery.js"></script>
<script type="text/javascript" src="../js/prettify/prettify.js"></script>
<!-- InstanceBeginEditable name="footerScripts" --> <!-- InstanceEndEditable -->
<script type="text/javascript">
$(function() { //shortcut for $(document).ready();
	prettyPrint();
	
	//Update the Copyright Date in the footer to be the current year.
	var crDate = document.getElementById('copyrightDate');
	var today = new Date();
	crDate.innerHTML = today.getFullYear();
});
</script>
</body>
<!-- InstanceEnd --></html>
